From: Mike Galbraith <efault@gmx.de>
Date: Fri, 7 Feb 2020 07:11:06 +0100
Subject: [PATCH] drm/i915/gt: use a LOCAL_IRQ_LOCK in __timeline_mark_lock()
Origin: https://www.kernel.org/pub/linux/kernel/projects/rt/5.6/older/patches-5.6.10-rt5.tar.xz

Quoting drm/i915/gt: Mark up the nested engine-pm timeline lock as irqsafe

    We use a fake timeline->mutex lock to reassure lockdep that the timeline
    is always locked when emitting requests. However, the use inside
    __engine_park() may be inside hardirq and so lockdep now complains about
    the mixed irq-state of the nested locked. Disable irqs around the
    lockdep tracking to keep it happy.

This lockdep appeasement breaks RT because we take sleeping locks between
__timeline_mark_lock()/unlock().  Use a LOCAL_IRQ_LOCK instead.

Signed-off-by: Mike Galbraith <efaukt@gmx.de>
Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
---
 drivers/gpu/drm/i915/gt/intel_engine_pm.c |    7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

--- a/drivers/gpu/drm/i915/gt/intel_engine_pm.c
+++ b/drivers/gpu/drm/i915/gt/intel_engine_pm.c
@@ -64,12 +64,15 @@ static int __engine_unpark(struct intel_
 }
 
 #if IS_ENABLED(CONFIG_LOCKDEP)
+#include <linux/locallock.h>
+
+static DEFINE_LOCAL_IRQ_LOCK(timeline_lock);
 
 static inline unsigned long __timeline_mark_lock(struct intel_context *ce)
 {
 	unsigned long flags;
 
-	local_irq_save(flags);
+	local_lock_irqsave(timeline_lock, flags);
 	mutex_acquire(&ce->timeline->mutex.dep_map, 2, 0, _THIS_IP_);
 
 	return flags;
@@ -79,7 +82,7 @@ static inline void __timeline_mark_unloc
 					  unsigned long flags)
 {
 	mutex_release(&ce->timeline->mutex.dep_map, _THIS_IP_);
-	local_irq_restore(flags);
+	local_unlock_irqrestore(timeline_lock, flags);
 }
 
 #else
